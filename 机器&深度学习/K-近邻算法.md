#### 什么是K-NN

K近邻算法是一种简单但也是常用的分类算法，它也可以应用于回归计算。

**一句话总结：近朱者赤近墨者黑！**

K-NN是无参数学习（这意味着它不会对底层数据的分布做出任何假设），它是基于实例（意味着我们的算法没有显示地学习模型。相反，它选择的是记忆训练实例）并在一个有监督的学习环境中使用

k 近邻算法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。k 近邻算法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其 k 个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻算法不具有显式的学习过程。

k 近邻算法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。 k值的选择、距离度量以及分类决策规则（多数表决）是k近邻算法的三个基本要素。（常用的距离向量是欧氏距离）



#### KNN 工作原理

K-NN用于分类时--输出是一个类别

1. 假设有一个带有标签的样本数据集（训练样本集），其中包含每条数据与所属分类的对应关系。
2. 输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较。
   1. 计算新数据与样本数据集中每条数据的距离。
   2. 对求得的所有距离进行排序（从小到大，越小表示越相似）。
   3. 取前 k （k 一般小于等于 20 ）个样本数据对应的分类标签。
3. 求 k 个数据中出现次数最多的分类标签作为新数据的分类。

> K 值的选择

K值小意味着噪声会对结果产生较大的影响，而k值大则会是计算成本高。这很大程度上取决于你的实际情况，在某些情况下，最好是遍历每个可能的值，然后自己根据实际来选择K值

> KNN 通俗理解

给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的 k 个实例，这 k 个实例的多数属于某个类，就把该输入实例分为这个类。

> KNN 开发流程

```
收集数据：任何方法
准备数据：距离计算所需要的数值，最好是结构化的数据格式
分析数据：任何方法
训练算法：此步骤不适用于 k-近邻算法
测试算法：计算错误率
使用算法：输入样本数据和结构化的输出结果，然后运行 k-近邻算法判断输入数据分类属于哪个分类，最后对计算出的分类执行后续处理
```

> KNN 算法特点

```
优点：精度高、对异常值不敏感、无数据输入假定
缺点：计算复杂度高、空间复杂度高
适用数据范围：数值型和标称型
```



#### 实例1

1、将文本记录转换为 NumPy 的解析程序

2、使用 Matplotlib 画二维散点图

- 归一化数据 （归一化是一个让权重变为统一的过程，更多细节请参考： https://www.zhihu.com/question/19951858 ）

| 序号 | 玩视频游戏所耗时间百分比 | 每年获得的飞行常客里程数 | 每周消费的冰淇淋公升数 | 样本分类 |
| ---- | ------------------------ | ------------------------ | ---------------------- | -------- |
| 1    | 0.8                      | 400                      | 0.5                    | 1        |
| 2    | 12                       | 134 000                  | 0.9                    | 3        |
| 3    | 0                        | 20 000                   | 1.1                    | 2        |
| 4    | 67                       | 32 000                   | 0.1                    | 2        |

样本3和样本4的距离： $$\sqrt{(0-67)^2 + (20000-32000)^2 + (1.1-0.1)^2 }$$

归一化特征值，消除特征之间量级不同导致的影响

**归一化定义：** 我是这样认为的，归一化就是要把你需要处理的数据经过处理后（通过某种算法）限制在你需要的一定范围内。首先归一化是为了后面数据处理的方便，其次是保正程序运行时收敛加快。 方法有如下：

线性函数转换，表达式如下：　　

```y=(x-MinValue)/(MaxValue-MinValue)　```　

说明：x、y分别为转换前、后的值，MaxValue、MinValue分别为样本的最大值和最小值。　

对数函数转换，表达式如下：　　

```y=log10(x)　```　

说明：以10为底的对数函数转换。

反余切函数转换，表达式如下：

```y=arctan(x)*2/PI　```

在统计学中，归一化的具体作用是归纳统一样本的统计分布性。归一化在0-1之间是统计的概率分布，归一化在-1--+1之间是统计的坐标分布

3、训练算法：此步骤不适用于 k-近邻算法

因为测试数据每一次都要与全量的训练数据进行比较，所以这个过程是没有必要的。

4、测试算法：使用海伦提供的部分数据作为测试样本。如果预测分类与实际类别不同，则标记为一个错误。

kNN 算法伪代码：

```
对于每一个在数据集中的数据点：
    计算目标的数据点（需要分类的数据点）与该数据点的距离
    将距离排序：从小到大
    选取前K个最短距离
    选取这K个中最多的分类类别
    返回该类别来作为目标数据点的预测值
```

5、使用算法：产生简单的命令行程序，然后海伦可以输入一些特征数据以判断对方是否为自己喜欢的类型。

#### 实例2

手写数字识别系统学习

#### 项目概述

构造一个能识别数字 0 到 9 的基于 KNN 分类器的手写数字识别系统。

需要识别的数字是存储在文本文件中的具有相同的色彩和大小：宽高是 32 像素 * 32 像素的黑白图像。

#### 开发流程

```
收集数据：提供文本文件。
准备数据：编写函数 img2vector(), 将图像格式转换为分类器使用的向量格式
分析数据：在 Python 命令提示符中检查数据，确保它符合要求
训练算法：此步骤不适用于 KNN
测试算法：编写函数使用提供的部分数据集作为测试样本，测试样本与非测试样本的
         区别在于测试样本是已经完成分类的数据，如果预测分类与实际类别不同，
         则标记为一个错误
使用算法：本例没有完成此步骤，若你感兴趣可以构建完整的应用程序，从图像中提取
         数字，并完成数字识别，美国的邮件分拣系统就是一个实际运行的类似系统
```

1、收集数据: 提供文本文件

2、准备数据: 编写函数 img2vector(), 将图像文本数据转换为分类器使用的向量

3、分析数据：在 Python 命令提示符中检查数据，确保它符合要求

4、使用算法



#### 小结

简单来说： 通过距离度量来计算查询点（query point）与每个训练数据点的距离，然后选出与查询点（query point）相近的K个最邻点（K nearest neighbors），使用分类决策来选出对应的标签来作为该查询点的标签。

>  KNN 三要素

1、K的取值

太大太小都不太好，可以用交叉验证（cross validation）来选取适合的k值。

2、距离度量 Metric/Distance Measure

距离度量 通常为 欧式距离（Euclidean distance），还可以是 Minkowski 距离 或者 曼哈顿距离。也可以是 地理空间中的一些距离公式。（更多细节可以参看 sklearn 中 valid_metric 部分）

3、分类决策 （decision rule）

分类决策 在 分类问题中 通常为通过少数服从多数 来选取票数最多的标签，在回归问题中通常为 K个最邻点的标签的平均值。

> 算法 （sklearn 上有三种）

Brute Force 暴力计算/线性扫描   （没有建树的过程、时间和空间复杂度 高 O[DN^2]）

KD Tree 使用二叉树根据数据维度来平分参数空间。

Ball Tree 使用一系列的超球体来平分训练数据集



参考链接

[apachecn--近邻算法](https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-近邻算法.md)