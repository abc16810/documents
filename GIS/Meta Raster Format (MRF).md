#### MRF – Meta Raster Format

mrf元栅格格式， GDAL 驱动程序内置

MRF是元栅格格式缩写，是一种将栅格存储与tile web服务和云计算结合起来的技术。虽然主要的目标领域是云地理信息系统，MRF技术也可以用于其他领域，如医学成像和科学数据处理

MRF 是

- 一种栅格存储格式
- web服务的瓦片缓存格式
- 另一个光栅的动态瓦片缓存

为了达到本文档的目的，光栅被定义为一个二维值数组。在信息技术中，光栅通常代表一幅图像，在这种情况下，数组元素称为像素，即图像元素的缩写。图像可以是灰度或彩色。在后一种情况下，每个像素对应多个值，通常每个值对应一个红、绿、蓝。在科学应用中，光栅通常用于表示采样标量场或矩阵，其中每个数组值是标量场在特定点上的数值。在地理信息科学(GIS)中，光栅可以是一幅地图图像，也可以是一组值。光栅是一种非常紧凑和有效的存储均匀采样数据的方法，因为坐标集不必与每个数据值一起存储。相反，通过了解光栅投影、一个或多个参考点和分辨率来计算坐标。

目前有许多光栅格式在使用。它们中的大多数已经开始作为用于磁盘存储或归档的图像格式。JPEG、PNG和TIFF是一些最著名的例子。作为图像格式，它们通常支持大小合理的灰度和彩色图像，并采用各种压缩算法来减少所需的存储空间。这些格式中的大多数在互联网出现之前就已经设计好了，并且一直在使用，因为它们很好地满足了它们的目的。然而，这些格式有很大的局限性，**例如用于存储非常大的图像或非图像数据时。**



MRF旨在利用现有的图像格式，同时解决它们的一些缺点，而不增加不必要的复杂性。以最简单的形式，MRF显式地提供平铺、空间索引和多种分辨率(`又名 overviews, pyramid, or resolution-sets`)支持。这是GIS中非常常见的一种方法，允许读取特定区域的数据，而不需要读取完整的栅格。它还允许的光栅尺寸远远超出了传统图像格式的可行性。 由于MRF文件中的瓦片本身可能以光栅格式存储，所以MRF适合作为web服务的瓦片存储格式。MRF也可以用作云栅格缓存格式，以提高web应用程序的性能。MRF将数据、索引和元数据隔离在不同的文件中，这允许根据需要为不同的组件使用不同的存储类，从而提高了效率，甚至在单个系统上也是如此

当然，还有其他技术试图解决同样的问题。例如，把图像块放在文件夹中，并强加一个已知的文件夹和文件命名策略的简单方法。这样做的好处是，不需要特殊的工具或应用程序来探索和管理较大的数据集。这种方法有些脆弱，而且不像乍一看那样具有可伸缩性，因为文件和操作系统开销会随着数据集的大小而显著增加。一个稍好的方法是使用数据库来存储tile。通常，数据库的开销比文件系统少，因此比文件夹中文件的方法略好一些。缺点是需要一个完整的数据库引擎，而大多数数据库功能(表、查询、事务)对光栅tile存储没有用处或不适用。此外，数据库期望并优化了比普通栅格平铺尺寸更小的记录。光栅固有的二维网格不是一个常见的数据库结构，填充光栅数据库的工具很少、非标准或必须从头编写

MRF采取了这两种方法之间的中间路线。通过仅提供所需的数据库功能部分，它提供了出色的可伸缩性。它不太依赖文件系统来进行块管理。它本身作为一个光栅，因此可以使用感知光栅的应用程序读写它。**性能和可伸缩性一直是MRF的主要设计目标，紧随其后的是简单性、可用性和灵活性。**MRF是作为GDAL驱动程序(地理空间数据抽象层)实现的，这允许MRF在许多GIS应用程序中立即被利用，并提供对文档良好的工具和工作流的访问。与大多数技术一样，如果想要获得良好的结果，了解MRF的特性和限制是很重要的。本文档包含详细的MRF文档



#### MRF文件结构

一个MRF数据集有三个组件:元数据、索引和数据。虽然通常每个组件都存储在单独的文件中，但也存在替代配置

```
blue_marble.idx
blue_marble.mrf
blue_marble.pjg
```

- 元数据包含关于光栅本身的高级信息。它被存储为XML格式的文件，这提高了可读性和可扩展性。元数据文件是对MRF数据集进行任何操作的起点。在GDAL中，可以使用该文件的XML内容来代替文件名，因此在某些情况下，元数据组件可以只是一个文本字符串。元数据文件按照惯例使用.mrf扩展名，也可以使用任何其他文件扩展名
- 索引与网格上的栅格贴图的二维组织有关。它包含一个或多个二维记录数组，其中每个记录保存光栅贴图的大小和偏移量。索引文件的大小与MRF中可能驻留的块的数量成比例。索引文件的组织取决于正在使用的MRF特性，但对于单个光栅，它们存储在左上角对齐的行主数组中。默认情况下，索引文件名与扩展名为.idx的元数据文件名相同

> 这三个组件都是访问MRF内容所必需的。仅从一两个组件完全恢复数据集通常是不可能的

#### 引用MRF

对特定MRF光栅的通常引用是用于元数据文件名。元数据文件可以有任何扩展名，GDAL中的文件格式检测是通过匹配文件中的前10个字符完成的，这些字符的值为“<MRF_META>”。例如，这个命令将工作，如果`test.mrf`是一个mrf元数据文件

```
gdalinfo test.mrf
```

引用MRF的另一种方法是将元数据的XML内容用作字符串。在这种情况下，必须在元数据字符串本身中显式地标识数据和索引文件名，因为不可能根据元数据文件名派生它们。当在命令行中使用此方法时，必须对shell特殊字符进行转义，以便将正确格式的XML字符串传递给GDAL open命令

#### MRF 操作

在创建MRF时，这三个组件文件通常都创建在同一个磁盘文件夹中。MRF格式特性之一是，可以在创建文件时立即读取数据集，甚至在实际写入任何数据之前。当一个MRF文件被写入时，也可以从它读取。如果为数据集定义了NoData值，则MRF中未被写入值的区域自动返回NoData，否则为零。`overviews`也是如此，只要将MRF文件标记为包含概述，就可以读取数据

一个MRF可以没有概览，也可以有一个特定概览缩放级数的所有概览，直到所有的栅格都能放进一个单一的贴图。没有对个别概述的MRF支持，所以它是不可能只有选择的少数!如果概览没有填充数据，它们将返回NoData值或零

该MRF驱动程序包含优化的代码，以生成使用`averaging `或`nearest `近值插值的概述，概述scale为2的幂。通用的GDAL概览生成代码也可以使用，在这种情况下，可以生成各种重采样方法或其他比例因子(3,4…)的概览。同样的规则也适用;所有的级别都必须存在，直到所有的栅格都适合一个贴图。如果MRF没有被标记为拥有概述，那么概述之间的比例将是传递给gdaladdo实用程序的第一个值。要生成和填充的第一个概述必须是最大的。还必须按顺序生成所有必要的概述，因为它们是由前一个递归生成的。通常情况下，传递给gdaladdo的级别列表应该是所有必要的比例因子的幂，就像这样

```
gdaladdo -r avg Test.mrf 2 4 8 16 32 64 128  # 以avg采样算法生成概述
```

或者3的幂

```
gdaladdo Test.mrf 3 9 27 81
```

为了方便起见，不必要的级别(大值)会生成警告，而不是错误。不可能将MRF概述从一个比例因子更改为另一个比例因子。但是，可以多次生成概览，而不会回收旧概览所使用的空间。虽然不推荐，但可以在GDAL中生成MRF外部概述，这些概述通常不是MRF格式，也不受MRF限制。

#### 概述采样

MRF驱动程序包含自己的优化重采样代码，使用平均或最近邻算法。内部代码比GDAL平均的开销更少，而且通常更快。它还针对具有大量NoData的mrf进行了优化。使用`-r avg`或`-r nnb`作为采样选项，以2作为比例因子触发使用MRF特定概述生成。只有scale 为2内部采样器工作!当需要时，MRF采样器会在图像的右侧和底部填充，保持比例因子为精确的2。相反，GDAL采样器在需要时通过重复行和/或列扩展输入，这使得所有概览的边界框相同，但两个连续概览之间的比率可能不完全为2。由于对于内部重采样器，尺度因子正好为2，因此，avg算法也可以看作是一种双线性插值。avg和nbb采样器都将NoData考虑在内

请注意，1.11版本之前的GDAL在生成概述时使用了一个错误的步骤。这个错误导致执行效率低下，文件大小超过必要的大小，有时还会产生可见的工件。这个问题已经解决了，不应该影响GDAL的未来版本。同样，使用-r average来使用GDAL平均插值，使用-r near来选择GDAL最近邻。如上所述，由于填充的不同，结果将与MRF内部采样器略有不同。对于内部采样器，进度指示器是每个生成的级别

GDAL重采样考虑了NoData值和alpha波段的存在，当alpha波段为零时，将其设置为零像素。为了强制gdal为alpha值为零的像素保留数据值，设置MRF创建选项`PHOTOMETRIC=MULTISPECTRAL`。这种方法的缺点是，它将把所有波段的光度解释设为未知，这可能会产生其他问题。MRF平均重采样或nnb重采样方法不受此影响，即使alpha波段为零，也会保持数据值不变。

对于具有概览的MRF文件，可以打开单个特定的概览级别，通常单独检查概览。概述是由它们的数字而不是相对规模(scale)来标识的，**0是最大的概述**。用于此目的的语法是`<filename>:MRF:L<n>`

例如，这个命令将显式地打开第一个概述级别: `gdalinfo test.mrf:MRF:L0`

**在现有MRF中插入数据**

使用MRF特定的实用程序mrf_insert，可以替换或修改MRF的一部分，并只生成概览中受影响的部分。这种设备使得高效地构建非常大的数据集成为可能，一次可以在较小的区域上操作。这个功能依赖于内部的MRF重采样，所以它将只工作在avg或nnb重采样模式和两级之间的幂次

设置创建选项`APPEND_SUBDATASET`为true以避免删除MRF头文件

由于缓存或克隆MRF可以被不同的进程同时使用，所以MRF驱动程序包含的代码允许在同一台机器上的多个进程安全地编写它，只要MRF驻留在本地磁盘上。这个特性对于其他类型的MRF可能很有用，例如，当使用mrf_insert更新同一个文件的不同区域时，或者当可以同时写入多个三维MRF Z-Slices时。要打开此功能，请手动向MRF元数据的Raster节点添加一个名为`mp_safe`的布尔属性，其值为on。这个特性在默认情况下是不开启的，因为它会在一定程度上减缓写操作。这个特性已经在Windows和Linux上进行了测试，在特定的操作和文件系统实现上可能会失败。它不能用于共享的网络文件系统，如CIFS和NFS，因为这些文件系统没有正确地实现文件追加模式

#### 由MRF支持的tile压缩类型

MRF中的Tiles使用多种支持的打包或压缩格式之一来存储。有些格式本身是标准的光栅格式，如JPEG、TIFF或PNG，而其他格式只是压缩格式。tile格式的选择通过GDAL创建选项COMPRESS传递给MRF驱动程序

**NONE 压缩**

顾名思义，NONE格式直接以行主要像素顺序存储tile数组。支持像素和BAND交织模式，以及所有GDAL支持的数据类型。NONE格式没有其他选项或特性，所有通用的MRF功能都适用。如果每个波段定义一个NoData值，则只包含在NoData值中的片不会存储在磁盘上。如果没有定义NoData值，则不存储只包含0的tile。与任何其他块格式一样，MRF不保证数据文件中块的任何特定顺序。对于多字节数据类型，字节的顺序取决于机器，除非设置了NETBYTEORDER选项，在这种情况下，字节以大端字节顺序写入。该规则适用于大多数没有显式控制数据值的其他格式(JPEG、PNG、TIF)。

**ZSTD 压缩**

ZSTD是一个通用的无损压缩算法，类似于DEFLATE，也是开源的。就其本身而言，在相同的压缩比下，它比DEFLATE快得多。MRF ZSTD可以处理所有的数据类型，并支持带和像素交织。ZSTD压缩级别可以通过提供一个质量数字(1到22之间的整数)来控制。MRF的默认级别是9，预期它将达到与DEFLATE在级别6时类似的压缩比，但要快得多。然而，MRF ZSTD使用了一个光栅特定的数据过滤器(见下文)，这大大提高了压缩比，同时几乎没有计算成本。一般来说，默认的ZSTD级别不应该被修改，它提供了很大的压缩并且速度很快。当需要时，当提供的值介于1到22之间时，可以使用QUALITY选项来选择不同的级别。请注意，较大的值可能会花费大量的时间，并且不一定会改善压缩。较低的数字会更快，但压缩效果会更小，而较高的数字在压缩效果更好的同时，会花费相当多的CPU时间。在有效范围之外的值将没有任何作用，ZSTD压缩级别将是9

ZSTD可以以两种方式使用，一种是作为独立的tile打包机制，另一种是作为第二遍压缩。后一种模式是通过将`ZSTD:ON`添加到自由表单列表`OPTIONS`中。ZSTD压缩格式相当于使用`OPTIONS=ZSTD:on`的NONE压缩。下面两个命令生成具有相同数据文件大小的mrf，尽管tile顺序可能不同。

```
gdal_translate –of MRF –co COMPRESS=ZSTD input.tif zstd.mrf
gdal_translate –of MRF –co COMPRESS=NONE -co OPTIONS="ZSTD:on" input.tif raw_zstd.mrf
```

在使用ZSTD进行最终压缩之前，MRF在tile数据上实现了一个字节增量过滤器之后的字节秩重排序。这个过滤器在大多数情况下大大改善了光栅压缩，特别是在写入多字节数据类型或像素交错块时。这个过滤器的计算成本可以忽略不计，特别是与ZSTD压缩本身相比。当ZSTD作为第二阶段压缩应用时，这个过滤器不适用，除非第一阶段为NONE

**PNG and PPNG 压缩**

PNG是一种众所周知的无损压缩图像格式。它内部使用光栅滤波器和DEFLATE算法。PNG是目前MRF的默认压缩机制。PNG压缩比DEFLATE慢，但会产生更小的数据文件，这也适合平铺web服务。PPNG是MRF特有的压缩名称，它代表调色板PNG。虽然这两种类型都可以有一个MRF级别的调色板，但PPNG也将调色板存储在每个PNG tile中。这种模式只适用于在网页上提供彩色图像的单个tile，否则常规的PNG压缩会导致更小的数据文件。PNG格式本身最多支持16位无符号整数数据类型。然而，MRF驱动程序可以将16位PNG视为包含无符号或有符号数据类型(Int16)，在这种情况下，存储在PNG中的值被解释为有符号的。QUALITY设置控制PNG的DEFLATE阶段，其行为与DEFLATE压缩中描述的相同。类似地，`Z_STRATEGY` band选项控制PNG的DEFLATE阶段。选择`Z_RLE`或`Z_HUFFMAN_ONLY`作为策略将导致更快的压缩，而牺牲大小，`Z_HUFFMAN_ONLY`是最快的。Z_FIXED和Z_FILTERED效果要小得多。策略设置的效果要比`QUALITY `值设置强得多

```
gdal_translate -of MRF –co COMPRESS=PNG –co OPTIONS="Z_STRATEGY:Z_RLE" –co QUALITY=50 input.tif output.mrf
```

**DEFLATE 压缩（弃用）**

> 建议使用ZSTD tile压缩

DEFLATE是一个著名的通用压缩算法，在开源的zlib库中实现。在MRF中，它可以以两种方式使用，一种是作为独立的tile打包机制，另一种是作为其他压缩格式的第二个压缩步骤。第二种含义是通过将DEFLATE:on添加到自由形式的列表OPTIONS中来激活的。使用DEFLATE:on选项的NONE压缩相当于使用DEFLATE作为压缩格式，即使元数据文件的内容不同。下面两个命令应该生成具有相同大小的数据文件的mrf，尽管tile顺序可能不同

```
gdal_translate –of MRF –co COMPRESS=DEFLATE input.tif deflate.mrf
gdal_translate –of MRF –co COMPRESS=NONE -co OPTIONS="DEFLATE:on" input.tif raw_and_deflate.mrf
```

zlib压缩级别是从QUALITY设置中计算出来的level = floor(QUALITY /10)。默认值是8，这是非常好的压缩，尽管很慢。建议将质量设置为60，作为压缩速度和大小之间的权衡。质量为0，对应质量值小于10，表示没有压缩

DEFLATE压缩可以使用不同的平铺标题。一般情况下应该使用默认值，因为这些选项之间的速度和大小差异是微不足道的。默认情况下，生成zlib兼容的tile头,`Gzip`或不使用平铺头文件, 通过设置布尔自由形式的OPTIONS `GZ`和`RAWZ`。如果两者都设置了，则头文件将为gzip。 zlib头是6个字节，包含一个由zlib特有的ADLER32算法计算的校验和。gzip报头稍微大一点，并且使用CRC32作为校验和，它比zlib报头稍微慢一点。Raw deflate既没有校验和，也没有报头，并且比gzip或zip报头略快一些

面的命令将生成一个MRF，其中每个tile都是gzip流

```
gdal_translate –of MRF –co COMPRESS=DEFLATE -co OPTIONS="GZ:on" input.tif gzipped.mrf
```

Zlib还支持稍微不同的压缩策略，而MRF可以控制这些策略。如果使用这些选项，压缩速度和输出大小将发生显著变化。这个选项只会影响压缩算法，所以生成的贴图总是可以被解压缩。有关策略标志的详细信息，请参阅zlib文档。使用的自由格式选项是`Z_STRATEGY`，有效值是

- Z_FILTERED 跳过输入流的可选过滤
- Z_HUFFMAN_ONLY 只执行DEFLATE中的Huffman编码部分
- Z_RLE 有点像RLE，在DEFLATE的范围内
- Z_FIXED  固定Huffman表

使用gzip样式头文件生成RLE压缩tile的示例:

```
gdal_translate –of MRF –co COMPRESS=DEFLATE -co OPTIONS="GZ:on Z_STRATEGY:Z_RLE" input.tif gzipped.mrf
```

**JPEG 压缩**

JPEG压缩是一种众所周知的无损图像压缩，它具有良好的视觉质量和良好的压缩性能。因为JPEG是一种众所周知的格式，所以被压缩为JPEG的MRF贴片适合作为web贴片使用。根据GDAL MRF的构建方式，MRF/JPEG格式可以处理8位数据，有时也可以处理12位数据。12位选项仅在使用GDAL内部libJPEG并且启用GDAL 12位JPEG时可用。MRF/JPEG可以在像素交错模式下处理多达10个波段。请注意，在大多数情况下，只有带有1或3个波段的8位jpeg格式适合web tile服务。MRF QUALITY输出选项值直接作为Q(量化)因子传递给JPEG库，默认值为85。请注意，JPEG Q值确实控制了输出质量和大小，但它不是线性的。关于Q的确切解释，请参考JPEG文档。支持0到100之间的值，60到85之间的合理范围，更大的值以增加大小为代价产生更好的视觉效果。对于三个波段交错，有几个编码选项可用，通过``PHOTOMETRIC` `设置控制。大多数情况下应该使用默认设置

- (DEFAULT) 这是最常见的JPEG样式，它使用YCbCr颜色空间，4:2:0采样。这种模式提供了良好的压缩和视觉质量。颜色空间的质量明显低于亮度，符合人类的视觉特征
- `YCC` 使用的YCbCr颜色空间与4:4:4采样，即它不是空间重采样。该设置生成的瓷砖颜色工件较少，比默认值大约三分之一。颜色转换本身会导致信息的轻微丢失，以及量化
- `RGB` 压缩为RGB，没有颜色转换，也没有空间重采样。对于相同的Q设置，这种模式生成的JPEG文件比默认值大得多，通常是默认值的两到三倍。具有此设置的MRF可以在同一Q上多次解码和重新编码，而不会造成任何数据质量下降

优化每个tile的Huffman编码表，而不是使用默认值，可以通过在OPTIONS列表中设置“OPTIMIZE=ON”来启用。选择这一选项将增加编码时间，并略微减小贴图大小，在大多数情况下，这两种改变都是相对较小的。
若要使用12位JPEG，请将数据类型设置为Int16或UInt16。

**brunsli (JPEG XL)**

虽然通常被称为JPEG文件，但通常用于存储JPEG压缩图像的格式实际上是JFIF。有一种新的格式叫做brunsli，它可以无损地来回转换到JFIF。Brunsli格式的优势在于，它可以将与JFIF相同的信息存储在平均小22%的包中。因为brunsli只是JPEG的一个更好的包装，所以结果仍然是JPEG压缩的，而且它具有完全相同的特征和限制。Brunsli支持所有标准的JFIF/JPEG特性，但值得注意的是，每个示例JPEG支持12位

与JFIF格式相比，使用brunsli格式确实对读写tiles的速度有很小的负面影响，因为brunsli增加了一个编解码器阶段。然而，与DEFLATE或PNG相比，读写仍然是快速的。当使用支持brunsli的GDAL和MRF进行编译，并且选择JPEG压缩时，额外的压缩是有益的，因此MRF将在可能的情况下以brunsli格式存储数据。在某些情况下，强制使用旧格式JFIF是有用的。例如，当tile要直接通过web服务到浏览器，或者当一个遗留的GDAL应用程序，编译没有brunsli支持可能被用来读取数据。在这些情况下，可以设置选项标志JFIF，迫使MRF只生成JFIF兼容的块:

```
gdal_translate -of MRF -co COMPRESS=JPEG -co OPTIONS=JFIF:1 input.tif output.mrf
```

**JPEG零增强(Zen)扩展**

MRF生成的JPEG贴片包含一个使用APP3“Zen”标签存储在JPEG Zen块中的零值像素掩码。如果Zen块的大小为0，则各个贴图中的所有像素都是非0的。当读取包含一个Zen块的JPEG时，MRF驱动程序将确保包含0的像素位置与掩码匹配。本质上，包含0的像素以一种无损的方式存储，当使用MRF驱动程序读取时，可以用作数据掩码。这消除了背景为黑色时的JPEG边缘工件，使Zen JPEG编码的MRF可以用作其他数据的叠加，只要黑色是透明的。使用MRF/JPEG存储可视化数据可以大大节省空间，这比下一个最佳选择(通常是无损的PNG或LERC)要好。因为Zen块是按照JFIF标准构建的，所以掩码将被遗留应用程序忽略，它将只解码JPEG图像内容。因为掩码是在MRF级别生成和使用的，所以它对GDAL是不可见的。此特性可用于8位或12位JPEG块，甚至在使用brunsli块格式时也能工作。

Zen位掩码组织在一个8x8的2D位掩码中，然后通过运行长度编码(RLE)压缩。对于大多数输入，包含掩码的Zen块的大小可以忽略不计。将黑色视为透明的潜在好处超过了这个尺寸的增加，因此这个功能不能被关闭

**JPNG 压缩**

jpg压缩是PNG或JPEG块的组合，取决于是否存在非透明像素。如果一个贴图中的所有像素都是不透明的，那么这个贴图将被存储为JPEG格式，否则它将被存储为带有Alpha通道的PNG格式。它以Luma-Alpha或RGBA图像的形式呈现给GDAL，它总是有2或4个波段，并且总是像素交错。大多数来自PNG和JPEG压缩的MRF选项仍然适用，包括JFIF标志。如果有完全不透明且可以存储为JPEG的tiles，那么数据文件将比只使用PNG时要小。注意，根据使用的选项和输入数据，可以看到从PNG到JPEG的转换。在大多数情况下，应该使用带有Zen掩码的普通JPEG格式，除非0不是透明的，并且需要逐渐透明。相对于MRF/JPEG/Zen的另一个优势是，遗留客户端(如web浏览器应用程序)通常不需要修改就能按预期显示tiles。

**TIFF压缩**

在TIFF压缩的MRF中，每个tile都是使用无损LZW内部压缩的TIFF光栅。支持大多数数据类型。请注意，tiles不是geotiff，它们不包含地理位置标签。这种压缩对于某些支持TIFF解码的客户机的web服务非常有用

**LERC压缩**

有限误差光栅压缩LERC是一种原始的Esri光栅压缩格式。与PNG、DEFLATE甚至是JPEG相比，使用LERC的好处是压缩速度非常快，并且对于大于8位的数据类型具有极好的压缩能力。LERC压缩可以是有损的，也可以是无损的。有损部分是由于初始量化阶段，由LERC最大误差值(LERC_PREC)控制，LERC最大误差值是一个浮点数。LERC可以更改存储的值，但更改总是小于或等于这个LERC最大错误值。因此，输出数据值的量或精度将是LERC_PREC值的两倍。如果LERC最大错误为零或太小，无法通过量化获得任何空间节省，则不修改输入数据值，LERC成为一种无损格式。输出压缩仍然可能发生，只要它是无损的。LERC包含一个显式的数据掩码，在MRF中始终是启用的。如果定义了这个掩码，则从NoData值中获取，否则使用0值。**NoData值没有存储在压缩的tile中，这使得LERC成为存储稀疏数据的好选择。**

在MRF中，对于整数类型，默认的LERC_PREC值为0.5，对应于无损压缩。在MRF中，浮点类型LERC精度默认为0.001(.002数据分辨率)。LERC实现的压缩在很大程度上依赖于LERC_PREC值，应该为每个特定的数据集仔细选择这个值。

为一个新的MRF文件设置一个自定义的LERC精度值，使用自由形式的MRF选项机制`-co OPTIONS="LERC_PREC:0.005"`

MRF支持两种不同类型的LERC压缩，LERC(默认为Lerc2)和LERC1

- LERC1 是原始的LERC代码，它实现了浮点的单频带压缩。MRF可以在调用LERC1之前将其转换为浮点数，从而将其用于整型数据。这意味着LERC1整数精度被限制为24位。MRF还通过连接每个单独波段的结果来模拟与LERC1压缩交织的像素。虽然在MRF中使用交错的LERC1像素没有大小优势，但在云环境中仍然可能有性能优势，因为所有波段的数据都是在一个操作中读取的。要选择LERC1而不是默认的LERC，请将V1=ON添加到选项字符串中`-co OPTIONS="LERC_PREC=0.01 V1=ON"`
- LERC (Lerc2) 支持比LERC1更多的数据类型和更高的精度，通常比LERC1更快。LERC的开发继续独立于MRF，可能会添加新特性，LERC版本可能会增加。除了LERC算法之外，LERC库还包括不同的压缩方法，这些方法可能导致更好的压缩。特别是对于字节输入数据，从Lerc版本2开始就使用了Huffman压缩，这通常会得到更好的压缩。LERC也处理像素交错数据，在LERC版本4中引入。默认情况下，MRF为每个tile使用LERC版本2写入LERC tile，或者使用其他方式使用LERC库支持的最新版本。使用较新的LERC库创建的MRF文件可能无法被使用较旧的LERC版本的MRF读取，这将产生LERC解码错误。当写入一个MRF - LERC时，可以使用自由的OPTION L2_VER选择一个特定的LERC版本。MRF驱动程序使用该选项来请求LERC编码不使用所选版本中不可用的任何特性。例如，要选择LERC版本3作为最大值，当指定值精度为0.2时，请使用`-co OPTIONS="L2_VER=3 LERC_PREC=0.2"`

由LERC压缩的MRF tiles可以用zlib (DEFLATE)进一步压缩，在某些情况下，zlib可以提高压缩性能，但代价是速度。DEFLATE的速度是不对称的，解压比压缩快，所以它对读速度的影响并不像对写速度的影响那么大。DEFLATE解压仍然比LERC慢很多，所以应该只在大小很关键或者解压速度不是瓶颈的时候使用，例如在从云存储读取瓦片的时候。要将DEFLATE添加到LERC，请在自由表单选项列表中添加“DEFLATE:ON”。`-co OPTIONS="LERC_PREC=0.01 DEFLATE:ON L2_VER:2"`

#### MRF 功能类型

**Static MRF**

这是基本存储格式MRF的名称，其中所有三个组件都在同一个文件夹中。在使用上，它类似于TIFF或许多其他光栅格式。

**Split MRF**

MRF的三个组件文件(元数据、索引和数据)分布在不同的存储系统上。这是通过在MRF元数据中拥有两个XML节点来实现的，每个节点都包含一个用于索引或数据文件的GDAL可访问文件名，类似于超链接。这些XML节点通常不是由GDAL MRF驱动程序创建的，一旦知道组件文件的位置，就需要通过修改元数据文件来添加这些节点。需要添加的两个节点分别为<IndexFile>和<DataFile>。它们作为<Raster>节点的子节点添加。内容只是一个GDAL可读路径，可以在其中找到数据或索引文件。` Split MRF `可以使用例如加速访问在缓慢的存储上的数据,通过保持元数据文件和索引文件在快速存储(本地SSD),同时拥有大型数据文件在硬盘NAS甚至云存储通过GDAL VSI(虚拟存储接口)。除了文件位置之外，Static和Split MRF之间没有什么区别。IndexFile和DataFile节点还可以包含一个名为offset的可选属性，该属性具有一个数值。这个值将被添加到对各个文件的所有访问的正常计算的文件偏移量中

**Caching MRF**

缓存MRF用作另一个光栅文件的缓存格式。原始栅格称为源栅格，而用于缓存的MRF成为缓存MRF。在GDAL中，只有读取缓存MRF是可能的，缓存MRF内容的更新会自动发生。不支持打开缓存MRF进行更新。通过缓存MRF写入父数据集也是不可能的。当通过MRF访问数据时，父光栅的某些GDAL功能可能不可用。只有静态光栅，包括静态/split mrf应该被缓存。链接缓存mrf是可能的，但缓存一致性可能成为一个问题。当缓存MRF数据文件的位置在一个本地磁盘上时，缓存MRF可以被同一台机器上的多个进程并行使用。例如，多个基于gdal的GIS应用程序可以同时活动，读取和共享相同的缓存MRF数据。

**创建MRF cache**

创建缓存MRF的基本方法是使用gdal_translate命令。除了普通的MRF创建选项外，缓存MRF数据集的创建还需要CACHEDSOURCE选项，该选项的值是要缓存的栅格数据集的文件名。任何GDAL可读的光栅格式都可以用作源代码，包括适当引用的字符串GDAL说明符。文件名应该是绝对的，除非父光栅文件与缓存MRF元数据文件位于相同的文件夹中

```
gdal_translate –of MRF -co NOCOPY=True –co CACHEDSOURCE=H12003_MB_1m_MLLW_14of16.tif H12003_MB_1m_MLLW_14of16.tif tst.mrf
```

在上面的命令中，CACHEDSOURCE选项的出现将该文件标记为缓存MRF，该选项的值将存储在MRF元数据文件中。由于使用的值是没有绝对路径的文件名，缓存mrf元数据文件将始终驻留在与父数据集文件相同的位置。绝对源路径也被支持，并且在大多数情况下是正确的选择。

上面的命令将创建缓存MRF元数据、数据和索引文件，但不会复制源数据。缓存MRF具有与普通静态MRF相同的结构，只是在元数据中它被标记为缓存MRF。可以删除索引和数据文件，然后使用MRF进行缓存，缓存MRF数据集的索引和数据文件在需要时创建为空。

警告:总是同时删除缓存MRF的索引和数据文件，否则会发生错误

**使用caching MRF**

这是简单的部分，只需使用缓存MRF读取数据，就像GDAL中的任何其他光栅格式一样。当打开时，MRF驱动程序将不会打开源数据集。当读取时，如果tile已经存在于缓存MRF中，那么它将被读取。否则，将打开源文件，并从源请求平铺。然后，在返回数据之前，将创建MRF块并存储在缓存MRF中。因此，第一次请求一个平铺时，它将具有源性能，任何随后的写操作将具有本地性能。延迟的源数据集打开提供了额外的性能。缓存MRF的性能取决于许多因素，包括缓存MRF和远程文件的页面大。当缓存MRF和远程文件具有相同的页面大小和对齐方式时，通常可以获得良好的性能。一个特殊的情况是，远程是像素交错的，但缓存MRF是频带交错的。在这种情况下，可以多次读取和解压缩远程页，每个输出带一次。但是，如果GDAL块缓存足够大，可以容纳所有的远程块，那么这种情况就不会发生，这些块将被重用。如果源页大小对于用户应用程序来说效率不高，建议使用合适的页面大小(可能是MRF)提前对源数据进行格式化

#### 三维 MRF

光栅通常是一个2D数据集，其特征是X和Y维度的大小以及颜色波段或通道的数量。MRF支持可选的第三维Z维。大小为N的MRF包含N个2D光栅，它们在X和Y中都具有相同的大小，具有相同的频带数量，使用相同的精确参数存储。每个2D光栅都由Z索引标识，Z索引是一个从0到N-1的整数。在GDAL中，一次只有一个2D光栅可用，在文件打开时确定，Z索引0是默认值。换句话说，一个正常的2D MRF是一个Z大小为1的3D MRF。除了IMAGE_STRUCTURE元数据域中的ZSIZE和ZSLICE元数据项之外，Z维度在GDAL中是不可见的



#### 覆盖 MRF

当覆盖一个MRF时，GDAL通常会尝试擦除存在的文件。为了避免无意地擦除数据或索引文件，MRF驱动程序不会这样做。这意味着，如果一个文件存在，并且被重复地用作gdal_translate的目标，那么数据文件将继续增长，而索引文件将保留其旧的内容，这是预期的行为。在某些情况下，这可能会产生问题，例如，当不同大小或结构的映像重用相同的文件名时，或者当MRF本身损坏时。在其中一些情况下可能会发生崩溃。在这些情况下，索引和数据文件应该在GDAL基础设施之外手工删除

#### MRF元数据架构

[offset，size]来表示平铺索引。按照惯例，没有写入数据的tile的索引大小为0 [R, 0]。这个索引记录将在读取时生成一个填充了0或NoData的平铺，偏移量的值是保留的，应该写成0。`caching/cloning MRFs `使用偏移值1和大小0[1,0]作为标记，表示源文件中的tile为0或NoData。它将被读取为零，而不会触发从源读取。

索引文件中tile记录的顺序取决于MRF的类型:

- 平铺记录通常以左上端方向存储，按行主顺序(Y, X)。
- 如果MRF包含多个通道(波段)，并以波段交错数据的形式存储，则波段索引先变化，然后是空间索引(Y, X, C)
- 如果MRF Z维大于1，则每个Z片索引是连续存储的，因此Z在Y (Z, Y, X, C)之后变化
- 如果MRF包含版本，则当前版本存储在索引文件的开头，紧随其后的是版本1，等等(V, Y, X, C)或(V, Z, Y, X, C)
- 如果有概览，则概览的tile索引向量紧跟在完整分辨率的索引向量之后，按照分辨率的降序(l;X,Y,C)或(l;Z,X,Y,C)。请注意，概览级别的向量小于前面概览或基本分辨率的向量



参考

- [GDAL](https://gdal.org/drivers/raster/marfa.html?highlight=mrf) 

- [**MRF** User Guide](https://github.com/nasa-gibs/mrf/blob/master/doc/MUG.md)